// utils/ticketPdf.js
const PDFDocument = require("pdfkit");
const qrcode = require("qrcode");
const bwipjs = require("bwip-js");
const moment = require("moment");

/**
 * generateTicketPdf(ticket = {}, stream = null)
 * - ticket: flexible object (supports many common key names and nested shapes)
 * - stream: optional writable stream (Express res). If omitted, returns Buffer.
 *
 * Final polished IRCTC-Hybrid (Layout B) variant.
 */
async function generateTicketPdf(ticket = {}, stream = null) {
  const doc = new PDFDocument({ size: "A4", margin: 40, autoFirstPage: false });

  if (stream) doc.pipe(stream);
  doc.addPage();

  const W = doc.page.width;
  const H = doc.page.height;

  // ---------- helpers ----------
  const safe = (keys, fallback = "") => {
    if (!Array.isArray(keys)) keys = [keys];
    for (const k of keys) {
      if (typeof k === "string") {
        if (ticket[k] != null && ticket[k] !== "") return ticket[k];
      } else if (typeof k === "function") {
        try {
          const v = k();
          if (v != null && v !== "") return v;
        } catch (e) { /* ignore */ }
      }
    }
    return fallback;
  };

  const fmtDate = (v) => {
    if (!v) return "-";
    const m = moment(v);
    return m.isValid() ? m.format("DD/MM/YYYY") : String(v);
  };
  const fmtDateTime = (v) => {
    if (!v) return "-";
    const m = moment(v);
    return m.isValid() ? m.format("DD/MM/YYYY, HH:mm:ss") : String(v);
  };
  const fmtTime = (v) => {
    if (!v) return "-";
    const fmts = ["HH:mm:ss", "HH:mm", "hh:mm A", moment.ISO_8601];
    for (const f of fmts) {
      const m = moment(v, f, true);
      if (m.isValid()) return m.format("HH:mm");
    }
    const m2 = moment(v);
    return m2.isValid() ? m2.format("HH:mm") : String(v);
  };

  try {
    // ---------- Header ----------
    const headerH = 84;
    doc.rect(0, 0, W, headerH).fill("#0f3b5f");
    try { doc.image("public/logo.png", 46, 18, { width: 56 }); } catch (e) { /* ignore */ }
    doc.fill("#ffffff").font("Helvetica-Bold").fontSize(26).text("RailSmart E-Ticket", 120, 26);
    doc.font("Helvetica").fontSize(10).fill("#ffffff").text("Intelligent Railway Ticket Booking System", 120, 54);

    // ---------- Card (slightly shorter to reduce whitespace) ----------
    const cardX = 48;
    const cardY = headerH + 18;
    const cardW = W - cardX * 2;
    const cardH = 200; // reduced from 220/230
    doc.roundedRect(cardX, cardY, cardW, cardH, 8).fill("#ffffff").stroke("#e6edf6");

    // ---------- Info box ----------
    const infoX = cardX + 12;
    const infoY = cardY + 12;
    const infoW = cardW - 24;
    const infoH = 96;
    doc.roundedRect(infoX, infoY, infoW, infoH, 6).fill("#fbfdff").stroke("#eef4fb");

    // Ticket left text
    const leftX = infoX + 10;
    let y = infoY + 8;
    const ticketId = safe(["ticket_id", "id"], "RS-000");
    doc.fill("#1f2937").font("Helvetica-Bold").fontSize(12).text(`Ticket ID: ${ticketId}`, leftX, y);

    const passenger = safe(["passenger_name", "passengerName", "user_email", "passengerEmail"], "");
    doc.font("Helvetica").fontSize(9).fill("#374151").text(passenger, leftX, y + 18);

    const booked = safe(["booking_date", "bookedOn", () => ticket.rawBookingDate], null);
    const bookedText = booked ? fmtDateTime(booked) : "-";
    doc.font("Helvetica").fontSize(9).fill("#667085").text(`Booked On: ${bookedText}`, leftX, y + 36);

    // ---------- PNR Layout C (stacked) ----------
    const pnrValue = safe([
      "pnr",             // your actual working field
      "pnr_no",
      "pnrNumber",
      "pnrno",
      () => ticket?.rawResponse?.[0]?.pnr,
      () => ticket?.response?.pnr
    ], "N/A");

    const pnrBoxW = 84;
    const pnrBoxH = 62;
    const pnrBoxX = infoX + infoW - pnrBoxW - 12;
    const pnrBoxY = infoY + 8;
    doc.roundedRect(pnrBoxX, pnrBoxY, pnrBoxW, pnrBoxH, 6).fill("#ffffff").stroke("#e6eaf2");
    doc.font("Helvetica-Bold").fontSize(9).fill("#0f3b5f").text("PNR", pnrBoxX + 8, pnrBoxY + 8, { width: pnrBoxW - 16, align: "center" });
    doc.font("Helvetica-Bold").fontSize(11).fill("#111827").text(pnrValue ? String(pnrValue) : "N/A", pnrBoxX + 8, pnrBoxY + 28, { width: pnrBoxW - 16, align: "center" });

    // ---------- QR & Barcode ----------
    const qrSize = 110;
    // place QR slightly left so PNR box and QR don't clash visually
    const qrX = infoX + infoW - qrSize - 14 - pnrBoxW; // shift left a bit
    const qrY = infoY + 6;
    try {
      const qrData = `ticket:${ticketId};pnr:${pnrValue || ""};train:${safe(["train_name","trainName"], "")};date:${safe(["travel_date","travelDate"], "")}`;
      const qrDataURL = await qrcode.toDataURL(qrData, { margin: 1, width: 300 });
      const qrBuf = Buffer.from(qrDataURL.split(",")[1], "base64");
      doc.image(qrBuf, qrX, qrY, { width: qrSize, height: qrSize });
    } catch (e) {
      console.error("QR generation failed:", e);
    }
    try {
      const barcodeBuf = await bwipjs.toBuffer({
        bcid: "code128",
        text: ticketId || pnrValue || "RS-000",
        scale: 2,
        height: 40,
        includetext: false
      });
      doc.image(barcodeBuf, qrX, qrY + qrSize + 6, { width: qrSize, height: 46 });
    } catch (e) {
      console.error("Barcode generation failed:", e);
    }

    // ---------- dotted separator ----------
    const sepY = infoY + infoH + 12;
    const dotStart = cardX + 14;
    const dotEnd = cardX + cardW - 14;
    for (let px = dotStart; px < dotEnd; px += 10) doc.rect(px, sepY, 1.8, 0.9).fill("#d6dbe6");

    // ---------- Journey Details (tighter, with disclaimer) ----------
    let detailsY = sepY + 18;
    doc.font("Helvetica-Bold").fontSize(16).fill("#0f3b5f").text("Journey Details", cardX + 12, detailsY);
    detailsY += 16;

    doc.font("Helvetica").fontSize(10).fill("#111827");
    const leftCol = cardX + 12;
    const rightCol = cardX + 320;
    let rowY = detailsY;

    doc.text(`Train: ${safe(["train_name","trainName"], "-")}`, leftCol, rowY);
    doc.text(`Seat: ${safe(["seat_no","seat"], "-")}`, rightCol, rowY);
    rowY += 13;

    doc.text(`PNR: ${pnrValue ? pnrValue : "-"}`, leftCol, rowY);
    rowY += 13;

    const route = safe(["route"], null) || (ticket.source && ticket.destination ? `${ticket.source} -> ${ticket.destination}` : "-");
    doc.text(`Route: ${route}`, leftCol, rowY);
    rowY += 13;

    const travelDate = safe(["travel_date","travelDate"], null);
    doc.text(`Travel Date: ${travelDate ? fmtDate(travelDate) : "-"}`, leftCol, rowY);
    rowY += 13;

    const departure = safe(["departure_time","departure"], null);
    const arrival = safe(["arrival_time","arrival"], null);
    doc.text(`Departure: ${departure ? fmtTime(departure) : "-"}`, leftCol, rowY);
    doc.text(`Arrival: ${arrival ? fmtTime(arrival) : "-"}`, rightCol, rowY);
    rowY += 16;

    // small IRCTC-style disclaimer under journey details (fills empty space nicely)
    doc.font("Helvetica").fontSize(9).fill("#667085")
       .text("This is a system generated ticket. No signature required.", leftCol, rowY, { width: cardW - 120 });
    rowY += 24;

    // ---------- Fare box (attached) ----------
    const fareW = 145;
    const fareH = 38;
    const fareX = cardX + cardW - fareW - 20;
    const fareY = rowY - 6;
    doc.roundedRect(fareX, fareY, fareW, fareH, 6).fill("#f8fafc").stroke("#e6eef6");
    doc.font("Helvetica").fontSize(11).fill("#0f3b5f").text("Fare", fareX + 12, fareY + 6);
    const fareAmt = Number(safe(["price","fare"], 0)) || 0;
    doc.font("Helvetica-Bold").fontSize(13).fill("#111827").text(`₹${fareAmt.toFixed(2)}`, fareX + 12, fareY + 18);

    // ---------- Watermark (darker & slightly larger) ----------
    doc.save();
    doc.rotate(-30, { origin: [W / 2, H / 2] });
    doc.font("Helvetica-Bold").fontSize(100).fillColor("#e6eef6").opacity(0.11)
       .text("RailSmart", W / 2 - 240, H / 2 - 10);
    doc.restore();
    doc.fillColor("#000").opacity(1);

    // ---------- Footer ----------
    const issuedAt = fmtDateTime(new Date());
    const verificationCode = pnrValue || ticketId || "N/A";
    const printedAt = moment().format("DD/MM/YYYY, HH:mm");

    // left footer: issued + verification code
    const footerLeftX = cardX + 4;
    const footerY = H - 132; // slightly higher so seal sits above it
    doc.font("Helvetica").fontSize(8).fill("#6b7280").text(`Issued: ${issuedAt}`, footerLeftX, footerY);
    doc.text(`Verification code: ${verificationCode}`, footerLeftX, footerY + 12);

    // center: printed timestamp
    doc.font("Helvetica").fontSize(8).fill("#6b7280").text(`Printed: ${printedAt}`, W / 2 - 40, H - 64);

    // ---------- Seal / verification box (moved up to reduce empty vertical space) ----------
    const sealW = 260;
    const sealH = 78;
    const sealX = W - sealW - 52;
    const sealY = H - 150; // moved up from -170 to -150
    doc.roundedRect(sealX, sealY, sealW, sealH, 8).fill("#ffffff").stroke("#dbe9f2");

    const stampR = 20;
    const stampCX = sealX + 36 + stampR;
    const stampCY = sealY + 28;
    doc.lineWidth(1.2).strokeColor("#c6d6e2");
    doc.circle(stampCX, stampCY, stampR).stroke();
    doc.circle(stampCX, stampCY, stampR - 6).fill("#f3f8fb");
    doc.fill("#0d874a").font("Helvetica-Bold").fontSize(14).text("✓", stampCX - doc.widthOfString("✓") / 2, stampCY - doc.currentLineHeight() / 2, { lineBreak: false });

    const sealTextX = stampCX + stampR + 14;
    let sy = sealY + 10;
    doc.font("Helvetica-Bold").fontSize(10).fill("#1a2e43").text("Digitally verified by RailSmart System", sealTextX, sy);
    sy += 16;
    doc.font("Helvetica").fontSize(8).fill("#52606d").text("This ticket is digitally signed and valid without a physical signature.", sealTextX, sy, { width: sealW - (sealTextX - sealX) - 18 });
    sy = sealY + sealH - 18;
    doc.font("Helvetica-Bold").fontSize(9).fill("#0f3b5f").text("RailSmart System", sealTextX, sy);

    try { doc.image("public/sign.png", sealX + 12, sealY + sealH - 40, { width: 64 }); } catch (e) { /* ignore */ }

    // contact line (moved slightly up)
    doc.font("Helvetica").fontSize(8).fill("#9aa4b2")
       .text("For any queries call 139 or email support@railsmart.com", cardX, H - 46, { width: W - cardX * 2, align: "center" });

    // finalize
    doc.end();

    if (stream) return;
    return await streamToBuffer(doc);

  } catch (err) {
    try { doc.end(); } catch (e) { /* ignore */ }
    console.error("PDF generation error:", err);
    throw err;
  }
}

// helper to collect buffer
function streamToBuffer(doc) {
  return new Promise((resolve, reject) => {
    const buffers = [];
    doc.on("data", (chunk) => buffers.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(buffers)));
    doc.on("error", (err) => reject(err));
  });
}

module.exports = { generateTicketPdf };
